# Firecracker snapshot versioning

This document describes how Firecracker persists it's state across multiple versions, diving deep into the snapshot format, encoding, compatibility and limitations. 

## Introduction
The design behind the snapshot implementation enables version tolerant save and restore across multiple Firecracker versions which we call a version space. Basically, one can pause a microvm, save it to disk with Firecracker version **v4** and later load it in Firecracker version **v2**. It also works  in reverse: Firecracker version **v4** loads what  **v2** saves. 

Below is an example graph showing backward and forward snapshot compatibility for a version space formally represented as [v2; vn]. This is the general picture, but keep in mind that future corner cases might remove edges from this graph.

![Version graph](
images/version_graph.png?raw=true
"Version graph")

## Overview
Firecracker persists the microvm state as 2 separate objects:
 - a  **guest memory** file
 - a **vmstate** file
 
*The block devices attached to the microvm are not considered part of the state and need to be managed separately.*

### Guest memory
The guest memory file is agnostic to Firecracker's version tolerant save/restore as it's contents are fully owned by the guest OS. The microVM memory is by choice saved as a dump of each page or as a sparse file of guest modified pages only. 
### Vmstate
Stores the internal state of the VMM (device emulation , KVM and vCPUs) with 2 expcetions - serial emulation and vsock backend. 

While we continuously improve and extend Firecracker's features by adding new options, devices or enhancements, the vmstate file changes both structurally and semantically with each new release. The state file includes versioning information and each Firecracker release implements distinct save/load logic for the supported version space. 

## Vmstate file format

###  A closer look
A vm state file is further split in 4 different fields:

| field | bits| description |
|----|----|----|
| magic_id | 64 | firecracker snapshot, architecture (x86_64/aarch64) and storage version.
| version  | 64 | the snapshot version number internally 1:1 mapped to specific Firecracker version.
| state | N*8 | Bincode blob containing the vm state.
 | crc| 64 | Optional CRC64 sum of magic_id, version and state.

Note: the last 16 bits of `magic_id` encode the storage version which specifies the encoding used for the `version` and `state` fields. The current implementation sets this field to 1 which identifies it as a [Serde bincode](https://github.com/servo/bincode) compatible encoder/decoder.

### Version tolerant ser/de
Firecracker reads and writes the `state` blob of the snapshot by using per version, separate serialization and deserialization logic. This logic is mostly autogenerated by a Rust procedural macro based on `struct`, `enum` and `union` annotations. Basically, one can say that these structures support versioning. The versioning logic is generated by parsing a structure's history log (encoded using Rust annotations) and emitting rust code.

Versioned serialization and deserialization is divided in 2 translation layers:
 - structural translator
 - semantic translator

The structural translator implements the logic to deserialize a structure field by field from any of it's previous versions and recreate the appropriate Rust POD structure at the latest version. It also implements the reverse: given a Rust POD structure it will serialize only the fields present at a specific target version.

The semantic translator works on top of the structural one and its only concern is translating the semantics of serialized/deserialized fields. 

This block diagram illustrates the concept:
![Versionize](
images/versionize.png?raw=true
"Versionize layers")

## Bincode encoding
During research and prototyping we have considered multiple storage formats. The criteria used for comparing these are: performance, size, rust support, specification, versioning support, community and tooling. Performance, size and rust support are hard requirements while all others will can be the subject of trade offs. 

More info about this comparison can be found [here](https://github.com/firecracker-microvm/firecracker/blob/9d427b33d989c3225d874210f6c2849465941dc0/docs/snapshotting/design.md).

Key benefits of using bincode versus everything else:
- Minimal snapshot size overhead
- Minimal CPU overhead 
- Simple implementation

## Snapshot compatibility
### Host kernel

The minimum kernel version required by Firecracker snapshots is 4.14. Snapshots can be saved and restored on different kernel versions without issues.

### Device model
The VM state file links some resources that are external to the snapshot:
- tap devices by device name
- block devices by block file path

To succesfully restore a microVM one should check that:
- tap devices are available and their name match the value in the vmstate file
- block device path in the vmstate is valid and points to the proper file.

### CPU model

Firecracker micromvs can run on any Intel x86_64 CPU models that support the hardware virtualizations extensions. Snapshots, however are not compatible across all Intel x86_64 CPU models. They are only compatible if the CPU features  exposed to the guest are an invariant when saving and restoring the snapshot.
The trivial scenario is creating and restoring snapshots on hosts that have the same CPU model. 
To relax this limitation Firecracker provides an API to select a CPU template. Firecracker CPU templates work by using CPUID masking that restricts the feature exposed features to a common denominator of multiple CPU models.


## Implementation

To enable cross version snapshot save/load we've designed and build two crates:
- [versionize](https://github.com/firecracker-microvm/versionize) - defines the Versionize trait, implements serialization of primitive types and provides a helper class to map Firecracker versions to individual structure versions.
- [versionize_derive](https://github.com/firecracker-microvm/versionize_derive) - exports a procedural macro that consumes structures,enums or unions and their annotations to produce an implementation of the `Versionize` trait

The vm state file format is implemented in the [snapshot crate](../src/snapshot/src/lib.rs) in the Firecracker repository. 
All Firecracker devices implement the [Persist](../src/snapshot/src/persist.rs) trait which exposes an interface that enables creation from and saving to the vmstate.